///////////////////////////////////////////////////////////////////////////////
// Header guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include <Engine/Utils.hpp>
#include <Engine/Core/Component.hpp>
#include <Engine/Core/Transform.hpp>
#include <SFML/Graphics.hpp>

///////////////////////////////////////////////////////////////////////////////
// Namespace tkd
///////////////////////////////////////////////////////////////////////////////
namespace tkd
{

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
///////////////////////////////////////////////////////////////////////////////
class SpriteRenderer : public Component
{
private:
    ///////////////////////////////////////////////////////////////////////////
    //
    ///////////////////////////////////////////////////////////////////////////
    sf::Texture m_texture;          //<!
    sf::Sprite m_sprite;            //<!
    bool m_textureLoaded = true;    //<!

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param texturePath
    ///
    ///////////////////////////////////////////////////////////////////////////
    SpriteRenderer(const String& texturePath)
        : m_texture(texturePath)
        , m_sprite(m_texture)
    {
        m_sprite.setOrigin(Vec2f(m_texture.getSize()) / 2.f);
    }

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param texturePath
    ///
    ///////////////////////////////////////////////////////////////////////////
    void loadTexture(const String& texturePath)
    {
        if (m_texture.loadFromFile(texturePath)) {
            m_sprite.setTexture(m_texture);
            m_textureLoaded = true;
            m_sprite.setOrigin(Vec2f(m_texture.getSize()) / 2.f);
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param rect
    ///
    ///////////////////////////////////////////////////////////////////////////
    void setTextureRect(const sf::IntRect& rect)
    {
        m_sprite.setTextureRect(rect);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    sf::Color getColor(void) const
    {
        return (m_sprite.getColor());
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param color
    ///
    ///////////////////////////////////////////////////////////////////////////
    void setColor(const sf::Color& color)
    {
        m_sprite.setColor(color);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param deltaTime
    ///
    ///////////////////////////////////////////////////////////////////////////
    void update(float deltaTime)
    {
        UNUSED(deltaTime);
        if (auto transform = getGameObject()->getComponent<Transform>()) {
            m_sprite.setPosition(transform->getPosition());
            m_sprite.setRotation(transform->getRotation());
            m_sprite.setScale(transform->getScale());
        }
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param window
    ///
    ///////////////////////////////////////////////////////////////////////////
    void render(sf::RenderTarget& target)
    {
        if (m_textureLoaded && isEnabled()) {
            target.draw(m_sprite);
        }
    }
};

} // namespace tkd
