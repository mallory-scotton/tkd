///////////////////////////////////////////////////////////////////////////////
// Header guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include <string>
#include <map>
#include <unordered_map>
#include <vector>
#include <optional>
#include <memory>
#include <array>
#include <filesystem>
#include <variant>
#include <stack>
#include <functional>
#include <atomic>
#include <thread>
#include <mutex>

///////////////////////////////////////////////////////////////////////////////
// Namespace tkd
///////////////////////////////////////////////////////////////////////////////
namespace tkd
{

///////////////////////////////////////////////////////////////////////////////
template <typename... Ts>
struct OverloadSet : Ts...
{
    using Ts::operator()...;
};
template <typename... Ts>
OverloadSet(Ts...) -> OverloadSet<Ts...>;

///////////////////////////////////////////////////////////////////////////////
using Path = std::filesystem::path;

///////////////////////////////////////////////////////////////////////////////
using Thread = std::thread;

///////////////////////////////////////////////////////////////////////////////
template <typename R> using Function = std::function<R>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using Atomic = std::atomic<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using Stack = std::stack<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename... Ts> using Variant = std::variant<Ts...>;

///////////////////////////////////////////////////////////////////////////////
template <typename T, typename U> using Map = std::map<T, U>;
template <typename T, typename U> using UMap = std::unordered_map<T, U>;

///////////////////////////////////////////////////////////////////////////////
template <typename T, typename U> using Pair = std::pair<T, U>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using Optional = std::optional<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using SharedPtr = std::shared_ptr<T>;
template <typename T> using SPtr = std::shared_ptr<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using UniquePtr = std::unique_ptr<T>;
template <typename T> using UPtr = std::unique_ptr<T>;

///////////////////////////////////////////////////////////////////////////////
template <typename T> using Vector = std::vector<T>;

///////////////////////////////////////////////////////////////////////////////
typedef unsigned char Uint8;
typedef unsigned short Uint16;
typedef unsigned int Uint32;
typedef unsigned long Uint64;

///////////////////////////////////////////////////////////////////////////////
template <typename T, Uint64 S> using Array = std::array<T, S>;

///////////////////////////////////////////////////////////////////////////////
typedef signed char Int8;
typedef signed short Int16;
typedef signed int Int32;
typedef signed long Int64;

///////////////////////////////////////////////////////////////////////////////
typedef int Socket;

///////////////////////////////////////////////////////////////////////////////
typedef unsigned char Byte;
typedef Vector<Byte> Data;

///////////////////////////////////////////////////////////////////////////////
typedef std::mutex Mutex;

///////////////////////////////////////////////////////////////////////////////
using String = std::string;

} // namespace tkd
