///////////////////////////////////////////////////////////////////////////////
// Header Guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include <Engine/Utils/Types.hpp>
#include <Engine/Utils/Constants.hpp>
#include <SFML/System/Vector2.hpp>
#include <iostream>
#include <exception>
#include <cmath>
#include <algorithm>

///////////////////////////////////////////////////////////////////////////////
// Namespace tkd
///////////////////////////////////////////////////////////////////////////////
namespace tkd
{

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
struct Vec2
{
public:
    ///////////////////////////////////////////////////////////////////////////
    ///////////////////////////////////////////////////////////////////////////
    union
    {
        struct { T x, y; };     //<!
        T xy[2];                //<!
    };

public:
    ///////////////////////////////////////////////////////////////////////////
    // Static properties
    ///////////////////////////////////////////////////////////////////////////
    static const Vec2<T> zeroVector;        //<!
    static const Vec2<T> oneVector;         //<!
    static const Vec2<T> upVector;          //<!
    static const Vec2<T> downVector;        //<!
    static const Vec2<T> rightVector;       //<!
    static const Vec2<T> leftVector;        //<!
    static const Vec2<T> xAxisVector;       //<!
    static const Vec2<T> yAxisVector;       //<!

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2(void) : x((T)0), y((T)0) {}

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param all
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2(T all) : x(all), y(all) {}

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param x
    /// \param y
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2(T x, T y) : x(x), y(y) {}

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam U
    ///
    /// \param other
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename U>
    Vec2(const Vec2<U>& other) : x((T)other.x), y((T)other.y) {}

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param other
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2(const sf::Vector2<T>& other) : x(other.x), y(other.y) {}

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param other
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename U>
    Vec2(const sf::Vector2<U>& other) : x((T)other.x), y((T)other.y) {}

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    operator sf::Vector2<T>(void)
    {
        return (sf::Vector2<T>(this->x, this->y));
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \tparam U
    ///
    ///////////////////////////////////////////////////////////////////////////
    template <typename U>
    operator sf::Vector2<U>(void)
    {
        return (sf::Vector2<U>((U)this->x, (U)this->y));
    };

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param index
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T& operator[](Int32 index)
    {
        if (index >= 2)
            throw std::out_of_range("Out of range");
        return (xy[index]);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param index
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    const T& operator[](Int32 index) const
    {
        if (index >= 2)
            throw std::out_of_range("Out of range");
        return (xy[index]);
    }

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param index
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T& component(Int32 index)
    {
        if (index >= 2)
            throw std::out_of_range("Out of range");
        return (xy[index]);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param index
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    const T& component(Int32 index) const
    {
        if (index >= 2)
            throw std::out_of_range("Out of range");
        return (xy[index]);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param other
    /// \param tolerance
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    bool equals(const Vec2<T>& other, float tolerance = KINDA_SMALL_NUMBER)
    {
        return (
            std::abs(x - other.x) <= (T)tolerance &&
            std::abs(y - other.y) <= (T)tolerance
        );
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param x
    /// \param y
    ///
    ///////////////////////////////////////////////////////////////////////////
    void set(const T x, const T y)
    {
        this->x = x;
        this->y = y;
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T getMax(void) const
    {
        return (std::max(x, y));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T getAbsMax(void) const
    {
        return (std::max(std::abs(x), std::abs(y)));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T getMin(void) const
    {
        return (std::min(x, y));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T getAbsMin(void) const
    {
        return (std::min(std::abs(x), std::abs(y)));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T length(void) const
    {
        return (std::sqrt((x * x) + (y * y)));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T squaredLength(void) const
    {
        return ((x * x) + (y * y));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param other
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    T dot(const Vec2<T>& other) const
    {
        return ((x * other.x) + (y * other.y));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param angle
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2<T> getRotated(float angle) const
    {
        float radians = angle * (PI / 180.f);
        float sinus = std::sin(radians);
        float cosine = std::cos(radians);

        return (Vec2<T>(
            (cosine * x) - (sinus * y),
            (sinus * x) - (cosine * y)
        ));
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param angle
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2<T> getSafeNormal(float tolerance = SMALL_NUMBER) const
    {
        const T sum = squaredLength();

        if (sum > (T)tolerance) {
            const float scale = 1.f / std::sqrt(sum);
            return (Vec2<T>((T)(x * scale), (T)(y * scale)));
        }
        return (Vec2<T>::zeroVector);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param angle
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    bool normalize(float tolerance = SMALL_NUMBER)
    {
        const T sum = squaredLength();

        if (sum > (T)tolerance) {
            const float scale = 1.f / std::sqrt(sum);

            x *= scale;
            y *= scale;
            return (true);
        }
        x = (T)0;
        y = (T)0;
        return (false);
    }
};

///////////////////////////////////////////////////////////////////////////////
// Definition of static properties
///////////////////////////////////////////////////////////////////////////////
template <typename T> const Vec2<T> Vec2<T>::zeroVector =   ((T) 0, (T) 0);
template <typename T> const Vec2<T> Vec2<T>::oneVector =    ((T) 1, (T) 1);
template <typename T> const Vec2<T> Vec2<T>::upVector =     ((T) 0, (T)-1);
template <typename T> const Vec2<T> Vec2<T>::downVector =   ((T) 0, (T) 1);
template <typename T> const Vec2<T> Vec2<T>::rightVector =  ((T) 1, (T) 0);
template <typename T> const Vec2<T> Vec2<T>::leftVector =   ((T)-1, (T) 0);
template <typename T> const Vec2<T> Vec2<T>::xAxisVector =  ((T) 1, (T) 0);
template <typename T> const Vec2<T> Vec2<T>::yAxisVector =  ((T) 0, (T) 1);

///////////////////////////////////////////////////////////////////////////////
// Type alias
///////////////////////////////////////////////////////////////////////////////
typedef Vec2<float>         Vec2f;      //<!
typedef Vec2<int>           Vec2i;      //<!
typedef Vec2<double>        Vec2d;      //<!
typedef Vec2<unsigned int>  Vec2u;      //<!

} // namespace tkd

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator+(const tkd::Vec2<T>& lhs)
{
    return (tkd::Vec2<T>(+lhs.x, +lhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator+(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return (tkd::Vec2<T>(lhs.x + rhs.x, lhs.y + rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator+(const tkd::Vec2<T>& lhs, T rhs)
{
    return (tkd::Vec2<T>(lhs.x + rhs, lhs.y + rhs));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator+(const T lhs, const tkd::Vec2<T>& rhs)
{
    return (tkd::Vec2<T>(lhs + rhs.x, lhs + rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator+=(tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    lhs.x += rhs.x;
    lhs.y += rhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator+=(tkd::Vec2<T>& lhs, const T rhs)
{
    lhs.x += rhs;
    lhs.y += rhs;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator-(const tkd::Vec2<T>& lhs)
{
    return (tkd::Vec2<T>(-lhs.x, -lhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator-(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return (tkd::Vec2<T>(lhs.x - rhs.x, lhs.y - rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator-(const tkd::Vec2<T>& lhs, T rhs)
{
    return (tkd::Vec2<T>(lhs.x - rhs, lhs.y - rhs));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator-(const T lhs, const tkd::Vec2<T>& rhs)
{
    return (tkd::Vec2<T>(lhs - rhs.x, lhs - rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator-=(tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    lhs.x -= rhs.x;
    lhs.y -= rhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator-=(tkd::Vec2<T>& lhs, const T rhs)
{
    lhs.x -= rhs;
    lhs.y -= rhs;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator*(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return (tkd::Vec2<T>(lhs.x * rhs.x, lhs.y * rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator*(const tkd::Vec2<T>& lhs, T rhs)
{
    return (tkd::Vec2<T>(lhs.x * rhs, lhs.y * rhs));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator*(const T lhs, const tkd::Vec2<T>& rhs)
{
    return (tkd::Vec2<T>(lhs * rhs.x, lhs * rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator*=(tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    lhs.x *= rhs.x;
    lhs.y *= rhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator*=(tkd::Vec2<T>& lhs, const T rhs)
{
    lhs.x *= rhs;
    lhs.y *= rhs;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator/(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return (tkd::Vec2<T>(lhs.x / rhs.x, lhs.y / rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator/(const tkd::Vec2<T>& lhs, T rhs)
{
    return (tkd::Vec2<T>(lhs.x / rhs, lhs.y / rhs));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T> operator/(const T lhs, const tkd::Vec2<T>& rhs)
{
    return (tkd::Vec2<T>(lhs / rhs.x, lhs / rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator/=(tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    lhs.x /= rhs.x;
    lhs.y /= rhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator/=(tkd::Vec2<T>& lhs, const T rhs)
{
    lhs.x /= rhs;
    lhs.y /= rhs;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator==(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs.x == rhs.x && lhs.y == rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator==(const tkd::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x == rhs && lhs.y == rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator==(const T lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs == rhs.x && lhs == rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator!=(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs.x != rhs.x || lhs.y != rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator!=(const tkd::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x != rhs || lhs.y != rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator!=(const T lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs != rhs.x || lhs != rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs.x < rhs.x && lhs.y < rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<(const tkd::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x < rhs && lhs.y < rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<(const T lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs < rhs.x && lhs < rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<=(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs.x <= rhs.x && lhs.y <= rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<=(const tkd::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x <= rhs && lhs.y <= rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator<=(const T lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs <= rhs.x && lhs <= rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs.x > rhs.x && lhs.y > rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>(const tkd::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x > rhs && lhs.y > rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>(const T lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs > rhs.x && lhs > rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>=(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs.x >= rhs.x && lhs.y >= rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>=(const tkd::Vec2<T>& lhs, const T rhs)
{
    return (lhs.x >= rhs && lhs.y >= rhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
bool operator>=(const T lhs, const tkd::Vec2<T>& rhs)
{
    return (lhs >= rhs.x && lhs >= rhs.y);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator++(tkd::Vec2<T>& lhs)
{
    ++lhs.x;
    ++lhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator++(tkd::Vec2<T>& lhs, int)
{
    tkd::Vec2<T> temp = lhs;
    ++lhs.x;
    ++lhs.y;
    return (temp);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator--(tkd::Vec2<T>& lhs)
{
    --lhs.x;
    --lhs.y;
    return (lhs);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
tkd::Vec2<T>& operator--(tkd::Vec2<T>& lhs, int)
{
    tkd::Vec2<T> temp = lhs;
    --lhs.x;
    --lhs.y;
    return (temp);
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
T operator^(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return ((lhs.x * rhs.y) - (lhs.y * rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param lhs
/// \param rhs
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
T operator|(const tkd::Vec2<T>& lhs, const tkd::Vec2<T>& rhs)
{
    return ((lhs.x * rhs.x) + (lhs.y * rhs.y));
}

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
/// \tparam T
///
/// \param os
/// \param vec
///
/// \return
///
///////////////////////////////////////////////////////////////////////////////
template <typename T>
std::ostream& operator<<(std::ostream& os, const tkd::Vec2<T>& vec)
{
    os << '(' << vec.x << ", " << vec.y << ')';
    return (os);
}
