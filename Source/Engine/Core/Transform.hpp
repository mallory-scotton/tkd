///////////////////////////////////////////////////////////////////////////////
// Header guard
///////////////////////////////////////////////////////////////////////////////
#pragma once

///////////////////////////////////////////////////////////////////////////////
// Dependencies
///////////////////////////////////////////////////////////////////////////////
#include <Engine/Utils.hpp>
#include <Engine/Core/Component.hpp>

///////////////////////////////////////////////////////////////////////////////
// Namespace tkd
///////////////////////////////////////////////////////////////////////////////
namespace tkd
{

///////////////////////////////////////////////////////////////////////////////
// Using angle instead of sf::Angle
///////////////////////////////////////////////////////////////////////////////
using Angle = sf::Angle;

///////////////////////////////////////////////////////////////////////////////
/// \brief
///
///////////////////////////////////////////////////////////////////////////////
class Transform : public Component
{
private:
    ///////////////////////////////////////////////////////////////////////////
    //
    ///////////////////////////////////////////////////////////////////////////
    Vec2f m_position = Vec2f(0.f);          //<!
    Angle m_rotation = sf::degrees(0.f);    //<!
    Vec2f m_scale = Vec2f(1.f);             //<!

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    explicit Transform(void) = default;

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    ///////////////////////////////////////////////////////////////////////////
    Transform(const Vec2f& position)
        : m_position(position)
    {}

public:
    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2f getPosition(void) const
    {
        return (m_position);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Angle getRotation(void) const
    {
        return (m_rotation);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \return
    ///
    ///////////////////////////////////////////////////////////////////////////
    Vec2f getScale(void) const
    {
        return (m_scale);
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param position
    ///
    ///////////////////////////////////////////////////////////////////////////
    void setPosition(const Vec2f& position)
    {
        m_position = position;
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param rotation
    ///
    ///////////////////////////////////////////////////////////////////////////
    void setRotation(const Angle& rotation)
    {
        m_rotation = rotation;
    }

    ///////////////////////////////////////////////////////////////////////////
    /// \brief
    ///
    /// \param scale
    ///
    ///////////////////////////////////////////////////////////////////////////
    void setScale(const Vec2f& scale)
    {
        m_scale = scale;
    }

    ///////////////////////////////////////////////////////////////////////////
    Vec2f transformPoint(const Vec2f& local) const
    {
        Vec2f scaled = local * m_scale;
        float radians = m_rotation.asRadians();
        Vec2f rotated(
            scaled.x * std::cos(radians) - scaled.y * std::sin(radians),
            scaled.x * std::sin(radians) - scaled.y * std::cos(radians)
        );

        return (rotated + m_position);
    }
};

} // namespace tkd
